
# Hypervisor 구현 방법을 공부하기 위한 가이드

## 레퍼런스, 메뉴얼

당연히 인텔/AMD 메뉴얼입니다. 무식하게 읽으면 어려워서, 중간에 포기하기 십상입니다만, 어느정도 개념이 잡히면 가장 먼저 보게 되는게 메뉴얼입니다. 경험상 인텔메뉴얼 만큼 좋은 자료는 없었습니다. (전 AMD SVM 은 안봐서 모릅니다. 동작 방식은 거의, 완전히 비슷합니다.)
개인적인 경험으로는 인텔메뉴얼의 Virtual Machine Extension 챕터를 세번정도 읽어보니, 머리속에 들어오기 시작하더군요.

## 온라인 자료
+ http://opensecuritytraining.info/AdvancedX86-VTX.html

강추! 개인적으로 가장 추천하는 자료입니다. 엔텔메뉴얼과 같이 보면서 공부하셔야 할것입니다. 최소한 여기 나오는 내용을 확실히 다 숙지해야 합니다.

+ http://www.slideshare.net/yonghwannoh/hypervisor-seminar

제가 예전에 만들었던 자료입니다. 마지막에 하이퍼바이저를 통해 안티키로거 
제품 우회하는 시연영상도 있습니다.

+ http://programming.or.kr/?p=312

[서승현님](https://www.facebook.com/hefos) 이 정리해두신 글입니다. KVM 코드 분석을 시작하시는 분들께 많이 도움될것 같습니다. 

## 책
+ Series 1 Xen으로 배우는 가상화 기술의 이해 - CPU 가상화
+ Series 2 Xen으로 배우는 가상화 기술의 이해 - 메모리 가상화
+ Series 3 Xen으로 배우는 가상화 기술의 이해 - I/O 가상화

한빛리얼타임에서 PDF 로 구매하실 수 있습니다. Xen 하이퍼바이저 소스코드를 분석하면서 공부한 내용을 정리해서 책으로 출판했네요.
대단하신분들인듯, 하지만 가상머신의 기본 개념이나 VT-x 스펙에 대한 기초지식이 없으면 이해하기 쉽지 않을 것 같네요.

## 코드
+ https://github.com/ionescu007/SimpleVisor

Windows Interernals 의 저자중 한명인 Alex Ionescue 가 만든 하이퍼바이저입니다. 최소한의 어셈블리코드로 엄청나게 간결하게 작성된 멋진 하이퍼바이저입니다. 공부를 위해서라면 최고의 선택이라고 생각합니다.


+ https://github.com/somma/HyperPlatform

또다른 멋진 오픈소스 구현입니다. 

+ Xen, KVM, VirtualBox

제품이니 당연히 매우 높은 완성도를 보이죠. 개인적으로는 VirtualBox 소스코드가 가장 읽기 편했습니다만, 기본 개념을 이해하지 못한상태에서는 해독 불가능한 암호로 보일겁니다. 

+ 기타

요즘은 다양한 하이퍼바이저 구현코드들을 쉽게 찾을 수 있더군요. 검색검색~~

## 도움이 될만 한 잔소리

### 아키텍처(x86, x64 같은)/운영체제를 공부해야 합니다
인터럽트 처리, 가상메모리 구현 같은, 리얼모드/보호모드 같은 운영체제 구현에 대한 기초 지식은 필수입니다. 어차피 하이퍼바이저는 운영체제가  직접 다루는 CPU 나 메모리를 가상화 하는 코드를 구현하는 작업입니다. 따라서 컨트롤 레지스터나 인터럽트들을 운영체제들이 어떻게 다루는지 정확히 알아야 제대로 구현하고, 트러블 슈팅이 가능하겠죠. 

공부하기 쉽지는 않지만 꽤 재밌는 것들을 할 수 있습니다. 

### Full Virtualization vs Para-Virtualzation
가상머신을 구현하는 방법에는 Full virtualization 과 Para-Virtualization 으로 나눌 수 있습니다. 
Vmware 나 Qemu 가 대표적인 Full Virtualization 제품에 속하고, Xen 이 대표적인 Para-Virtualization 제품에 속했습니다(과거형입니다). 

전자는 모든 명령어를 가상화 하는겁니다. 모든 CPU 명령어를 에뮬레이트하기때문에 완전히 새로운 명령어 체계를 사용하는 아키텍처라 해도 가상화 할 수 있겠죠. 하지만 당연히 느립니다. 

후자는 꼭 필요한 명령어만 가상화 합니다. 예를들어 아래와 같은 명령어가 있다고 가정합니다.

``` 
xor eax, eax
mov cr0, eax
``` 

첫번째 명령어는 그냥 범용 레지스터를 다르는 명령어이기 때문에 가상화 하지 않아도 됩니다. 실제 하드웨어를 그대로 사용하기 때문에 당연히 100% 하드웨어 성능을 냅니다. 하지만 두번째 명령어는 컨트롤 레지스터를 갱신해야 하기 때문에 반드시 가상화 해야 합니다. 


첫번째 명령어 처럼 하드웨어를 직접 활용하는 걸 `Direct execution` 이라고 합니다. 이렇게 꼭 필요한 중요한 명령어만 가상화 하는 것을 Para-Virtualization 이라고 합니다. 당연히 Full Virtualization 보다 성능이 좋아지겠죠?


Para-Virtualization 을 구현하기 위해서는 결국 꼭 가상화해야 하는 명령어와 그렇지 않은 명령어를 구분할 수 있어야 합니다. 그래서 커널을 직접 수정하는 방식을 활용했습니다. `mov cr0, eax` 같은 명령어를 찾아서 가상머신에게 가상화해달라고 요청하도록 커널코드를 직접 수정했습니다. 응용프로그램은 어차피 반드시 가상화 해야 하는 명령어를 사용하지 않으니 별 문제 없겠죠.


이렇게 가상머신에게 해당 명령어를 가상화해달라고 요청하는것을 `하이퍼 콜(hyper call) - vm 과 host 간 호출` 이라고 합니다.
그래서 Xen 에서 리눅스 올리려면, 전용 리눅스 커널을 사용해야 했습니다.


그런데 Windows 같은 운영체제는 커널을 직접 수정할 수 없기때문에, VT-x/SVM 기술이 나오기 전까지는 Para-Virtualization 방식의 가상머신 제품은 Windows 운영체제를 지원하지 못했습니다. 재밌는건 Vmware 같은 경우 Full Virtualization 방식임에도 불구하고 Xen 같은 제품보다 더 빨랐다는...


아무튼 옛날엔 그랬고, VT-x/SVM 이 나온 이후 가상머신을 만드는 방식이 매우 간편해졌습니다. 간편해 진게 아니라, 간편하게 만든것이죠.
앞에서 얘기했던 반드시 가상화 해야 하는 명령어와 그렇지 않은 명령어를 CPU, 즉 아키텍처에서 알아서 구분해줍니다. 가상머신 개발자는 CPU 가 알려주는 반드시 가상화하라고 통지하는 이벤트를 상황에 맞게 알아서 잘 처리해주면 됩니다. 이걸 `VMExit` 이라고 합니다. 
저는 `하이퍼바이저 구현은 VM Exit handler/callback 작성` 이라고 표현하곤 합니다.


따라서 하드웨어 가상화 기술이 나온 이후에는 Para-Virtualization 이니 뭐니 하는게 필요가 없죠. 그렇기 때문에 이제는 Xen 도 Windows 를 가상화할 수 있게 된겁니다. 개발하기도 훨씬 쉬워졌죠. 만세~


### Nested VM ?
가상머신 안에 또 가상머신 안에 또 가상머신?

무지막지하게 느릴까요? 당연히 느려지기야 하겠지만, 앞에서 얘기한 direct execution 때문에 그렇게 미친듯이 느려지지는 않을것입니다. 하이퍼바이저 개발자 입장에서는 관리할 자료구조가 훨씬 복잡해지고, 메모리 변환등으로 인해 복잡하긴 하겠지만요.


### QEMU 에 대해서
QEMU 는 원래 에뮬레이터입니다. 
에뮬레이터이기 때문에 호스트가 x86 이라도 x64, ARM 등의 명령어를 에뮬레이트 할 수 있기때문에 다양한 아키텍처를 지원할 수 있죠. 다양한 CPU를 소프트웨어로 에뮬레이트 할 수 있으니까요. 세상에 있는 모든 cpu 를 지원한다죠? 그렇기 때문에 엄청 느렸습니다.

하드웨어 가상화(VT-x, SVM 같은) 기술이 나온 이후, CPU 에뮬레이트는 하드웨어 가상화 기능을 활용하기 시작했습니다. 그게 바로 KVM 이구요. 나머지 하드웨어들은 소프트웨어로 에뮬레이팅 합니다. 다른 Vmware, Virttual Box 같은 가상머신 제품도 마찬가지 입니다.

만일 QEMU로 호스트의 아키텍처와 다른 아키텍처를 가상머신으로 돌리고자 한다면, VT-x 같은 기술을 활용 할 수 없기때문에 100% 에뮬레이팅에 의존 할 수 없을 겁니다. 느리겠죠?

간략히 얘기하자면, QEMU 는 다양한 디바이스/하드웨어에 대한 에뮬레이팅을 담당하고, KVM 은 CPU/Memory 가상화를 담당한다고 보시면 됩니다. **따라서 VT-x/SVM 구현에 관심있는 분이라면 QEMU 코드를 살펴보기보다는 리눅스 커널에 포함된 KVM 구현 코드를 분석하셔야 합니다.**    


